---
layout: post
title:  "Dagger 시작하기"
date:   2025-07-07 08:06:00 +0900
categories: SW Engineering
---


# Dagger.io란 무엇인가? CI/CD의 새로운 패러다임

Dagger.io는 소프트웨어 엔지니어링 워크플로우를 구성하고 실행하기 위한 플랫폼입니다. 기존의 CI/CD 방식이 주로 YAML 파일을 사용하여 일련의 셸 명령어 단계를 '선언'하는 방식이었다면, Dagger는 이 패러다임을 근본적으로 전환합니다. Dagger는 개발자가 자신이 선호하는 프로그래밍 언어(Go, Python, TypeScript 등)와 Dagger SDK를 사용하여 파이프라인 로직을 직접 '프로그래밍'할 수 있게 합니다.
이는 단순히 CI 스크립트를 작성하는 것을 넘어, CI 파이프라인 자체를 하나의 독립적인 애플리케이션처럼 개발하는 것을 의미합니다. 이러한 "CI as Code" 철학은 다음과 같은 강력한 이점을 제공합니다.
 * 타입 안전성(Type Safety): 컴파일 또는 실행 전에 타입 오류를 발견할 수 있습니다.
 * IDE 통합: 코드 자동 완성, 실시간 오류 검사, 디버깅 등 최신 IDE의 모든 기능을 활용할 수 있습니다.
 * 네이티브 테스트: 애플리케이션 코드를 테스트하듯 파이프라인 로직도 단위 테스트 및 통합 테스트를 작성할 수 있습니다.
 * 고급 로직 구현: 반복문, 조건문, 추상화 등 복잡한 로직을 불안정한 셸 스크립트 없이 깔끔하게 구현할 수 있습니다.

Dagger의 핵심 엔진은 docker build를 구동하는 것과 동일한 구성 요소인 BuildKit의 맞춤형 버전으로 구동됩니다. 이는 Dagger가 컨테이너 기술의 강력한 캐싱과 병렬 처리 능력을 기반으로 하고 있음을 시사합니다.
기존 방식(Shell Script, Dockerfile, YAML)의 문제점과 Dagger의 해결책
소프트웨어 개발이 복잡해지면서 CI/CD 파이프라인은 "장인이 만든 셸 스크립트와 관리 불가능한 YAML 코드의 미로"로 변질되기 쉽습니다. 이러한 전통적인 방식은 다음과 같은 두 가지 근본적인 문제를 안고 있습니다.
 * 유지보수성의 문제: Bash 스크립트와 YAML은 복잡한 로직을 표현하기에 부적합하며, 가독성이 떨어지고 디버깅이 어렵습니다. 이로 인해 CI 서버에서만 오류를 확인할 수 있는 "밀어넣고 기도하기(push and pray)" 방식의 개발 주기가 반복됩니다.
 * 재현성의 문제: "내 컴퓨터에서는 잘 되는데(it works on my machine)" 문제는 DevOps의 오랜 숙제입니다. 개발자의 로컬 환경과 CI 서버 환경 간의 미세한 차이(도구 버전, 운영체제, 라이브러리 등)로 인해 파이프라인이 예기치 않게 실패하는 경우가 많습니다.
Dagger는 이 두 가지 문제를 해결하기 위해 설계되었습니다. 첫째, SDK를 제공하여 유지보수성 문제를 해결합니다. 둘째, Dagger의 가장 핵심적인 아키텍처 결정인 모든 것을 컨테이너에서 실행하는 모델을 통해 재현성 문제를 해결합니다.

Dagger 파이프라인의 모든 작업(Dagger Function)은 격리된 컨테이너 내부에서 실행됩니다. 이는 다음과 같은 이점을 보장합니다.
 * 완벽한 환경 일관성: 로컬 머신, CI 서버, 다른 개발자의 머신 어디에서 실행하든 동일한 컨테이너 환경에서 실행되므로 결과가 항상 동일합니다.
 * 종속성 격리: 도구 버전 충돌이나 OS 차이(macOS vs. Linux)로 인한 문제가 원천적으로 차단됩니다.
 * 깨끗한 실행 환경: 이전 실행에서 남은 아티팩트나 더러운 캐시의 영향을 받지 않습니다.
결론적으로 Dagger는 단순히 더 나은 스크립팅 도구가 아니라, 개발 환경과 CI 환경의 완벽한 일치를 통해 진정한 의미의 이식성과 재현성을 달성하는 시스템입니다.

# 개발 환경 구축 및 첫 Dagger 파이프라인 실행

이 파트에서는 Dagger를 시작하기 위한 실질적인 단계를 안내합니다. Dagger CLI를 설치하고, Go, Python, TypeScript를 사용하여 간단한 "Hello, World" 모듈을 만들고 실행하는 과정을 다룹니다.
사전 준비물
Dagger를 사용하기 전에 시스템에 다음 소프트웨어가 설치되어 실행 중인지 확인해야 합니다.

 * 컨테이너 런타임: Dagger는 Dagger 엔진을 컨테이너로 실행하므로 Docker, Podman, nerdctl 등 OCI 호환 컨테이너 런타임이 반드시 필요합니다.
 * Git: Dagger 모듈은 Git을 통해 소스 코드를 관리하고 공유하는 경우가 많으므로 Git이 설치되어 있어야 합니다.
Dagger CLI 최신 버전 설치
Dagger CLI는 각 운영체제에 맞는 간단한 명령어로 설치할 수 있습니다. 항상 최신 버전을 사용하는 것이 권장됩니다.
 * macOS (Homebrew 사용):
   brew install dagger/tap/dagger

 * Linux (설치 스크립트 사용):
   curl -fsSL https://dl.dagger.io/dagger/install.sh | sh

   이 명령어는 Dagger를 $HOME/.local/bin에 설치합니다. 이 경로가 PATH 환경 변수에 포함되어 있는지 확인해야 합니다. 전역으로 설치하려면 BIN_DIR을 지정할 수 있습니다.
 * Windows (winget 사용):
   winget install Dagger.Cli

설치가 완료되면 다음 명령어를 실행하여 버전 정보를 확인하고 설치가 성공했는지 검증합니다.
dagger version

## "Hello, World!" Dagger 모듈 생성 및 실행

이제 첫 Dagger 모듈을 만들어 보겠습니다. Dagger 모듈은 재사용 가능한 Dagger 함수의 모음이며, dagger init 명령어로 간단히 생성할 수 있습니다.

### 1. 프로젝트 디렉토리 생성
먼저 프로젝트를 위한 새 디렉토리를 만듭니다.

```bash
mkdir hello-dagger-world
cd hello-dagger-world
```

### 2. Dagger 모듈 초기화
dagger init 명령어를 사용하여 모듈을 초기화합니다. --sdk 플래그로 원하는 언어를 선택할 수 있습니다. 여기서는 Go, Python, TypeScript 예시를 모두 보여줍니다.
 * Go:
   dagger init --sdk=go --name=hello-dagger

 * Python:
   dagger init --sdk=python --name=hello-dagger

 * TypeScript:
   dagger init --sdk=typescript --name=hello-dagger

이 명령어는 dagger init의 게이트웨이 역할을 하며, 단순히 파일 몇 개를 생성하는 것을 넘어 각 언어 생태계에 맞는 완전한 프로젝트 구조를 부트스트랩합니다.

### 3. 생성된 파일 구조 살펴보기
init 명령어 실행 후 생성된 파일들을 살펴보면 Dagger가 각 언어의 표준을 어떻게 존중하는지 알 수 있습니다.
 * 공통 파일:
   * dagger.json: 모듈의 이름, SDK 버전, 종속성 등 메타데이터를 정의하는 설정 파일입니다.
 * Go (--sdk=go):
   * main.go: Dagger 함수를 작성하는 기본 파일입니다.
   * go.mod, go.sum: Go의 표준 의존성 관리 파일입니다. Dagger 모듈도 일반적인 Go 프로젝트처럼 의존성을 가질 수 있습니다.
 * Python (--sdk=python):
   * src/hello_dagger/__init__.py: Dagger 함수를 작성하는 파일입니다.
   * pyproject.toml: Python의 표준 프로젝트 설정 및 의존성 관리 파일입니다.
 * TypeScript (--sdk=typescript):
   * src/index.ts: Dagger 함수를 작성하는 기본 파일입니다.
   * package.json: Node.js/TypeScript 프로젝트의 의존성 및 스크립트를 관리하는 파일입니다.
이처럼 Dagger 모듈은 각 언어의 표준 도구와 워크플로우를 그대로 사용할 수 있는 일급 시민(first-class citizen)으로 설계되었습니다.

### 4. Dagger 함수 수정하기
생성된 기본 함수를 더 명확한 "Hello, World" 예제로 수정해 보겠습니다.
 * Python (src/hello_dagger/main.py):
```python
import dagger
from dagger import dag, function, object_type

@object_type
class HelloDagger:
    @function
    def hello(self, name: str = "World") -> str:
        """이름을 받아 인사말을 반환합니다."""
        return f"Hello, {name}!"
```

### 5. Dagger 함수 실행하기
이제 dagger call 명령어를 사용하여 작성한 함수를 실행합니다.
 * 기본 실행 (기본값 "World" 사용):
   dagger call hello

   예상 출력:
   Hello, World!

 * 인자 전달:
   dagger call hello --name="Dagger"

   예상 출력:
   Hello, Dagger!

이 간단한 과정을 통해 Dagger 개발 환경을 구축하고, 첫 모듈을 생성하며, CLI를 통해 함수를 실행하는 기본 워크플로우를 경험했습니다. 이제 Dagger API의 핵심 구성 요소를 더 깊이 탐색할 준비가 되었습니다.


# 주요 CI/CD 플랫폼과의 통합
Dagger의 가장 큰 장점 중 하나는 기존 CI/CD 인프라를 대체하는 것이 아니라 보강하고 개선한다는 점입니다. 복잡한 파이프라인 로직은 Dagger 모듈 코드로 옮겨가고, CI 플랫폼의 역할은 해당 Dagger 함수를 호출하는 "단순 실행기(dumb runner)"로 축소됩니다. 이를 통해 파이프라인의 이식성이 극대화되고 특정 CI 벤더에 대한 종속성이 줄어듭니다. 이 파트에서는 GitHub Actions, GitLab CI, Jenkins와의 구체적인 연동 방법을 예제와 함께 설명합니다.
GitHub Actions 연동
GitHub Actions는 dagger/dagger-for-github라는 공식 액션을 통해 Dagger와 매우 간편하게 통합됩니다.
.github/workflows/ci.yml 설정 예시:

```yaml
name: Dagger CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Dagger Pipeline
        uses: dagger/dagger-for-github@v5 # 항상 특정 버전을 사용하는 것을 권장
        with:
          # 실행할 Dagger 함수 지정 (예: Part 4의 Go 프로젝트)
          # 'all' 함수를 호출
          verb: call
          args: all
          
          # Dagger Cloud 연동 (선택 사항)
          # GitHub Secrets에 DAGGER_CLOUD_TOKEN 저장 필요
          cloud-token: ${{ secrets.DAGGER_CLOUD_TOKEN }}
```

설명:
 * uses: dagger/dagger-for-github@v5: Dagger 공식 액션을 사용합니다. main이나 latest 대신 명시적인 버전을 사용하는 것이 안정성을 위해 권장됩니다.
 * with: 액션에 전달할 파라미터를 정의합니다.
   * verb: call: dagger call 명령어를 실행하도록 지정합니다.
   * args: all: 호출할 함수 이름과 인자를 지정합니다. 여기서는 인자 없는 all 함수를 호출합니다.
   * cloud-token: Dagger Cloud 토큰을 전달하여 파이프라인 실행을 시각화하고 추적할 수 있습니다. 이 값은 GitHub 저장소의 Secrets에 DAGGER_CLOUD_TOKEN이라는 이름으로 저장해야 합니다.
GitLab CI 연동
GitLab CI에서는 Docker-in-Docker(dind) 서비스를 사용하여 Dagger 엔진을 실행하는 것이 일반적인 패턴입니다.
.gitlab-ci.yml 설정 예시:
#.docker 템플릿: dind 서비스와 환경 변수 설정
.docker:
  image: docker:latest
  services:
    - name: docker:dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2

#.dagger 템플릿: Dagger CLI 설치
.dagger:
  extends:.docker
  before_script:
    - apk add --no-cache curl
    - curl -L https://dl.dagger.io/dagger/install.sh | sh
    - export PATH="$HOME/.local/bin:$PATH"

# 실제 파이프라인 잡
dagger-pipeline:
  extends:.dagger
  stage: build
  script:
    - dagger call all # Dagger 함수 호출
  variables:
    # GitLab CI/CD 변수에서 토큰을 가져옴
    DAGGER_CLOUD_TOKEN: $DAGGER_CLOUD_TOKEN

설명:
 * .docker 템플릿: YAML의 앵커 기능을 사용하여 재사용 가능한 dind 설정을 정의합니다. docker:dind 서비스를 실행하고, DOCKER_HOST를 설정하여 파이프라인 잡이 dind 컨테이너와 통신할 수 있도록 합니다.
 * .dagger 템플릿: .docker 설정을 상속받아 before_script에서 curl을 사용하여 Dagger CLI를 설치합니다.
 * dagger-pipeline 잡: .dagger 템플릿을 상속받아 script 섹션에서 dagger call all 명령을 실행합니다. DAGGER_CLOUD_TOKEN은 GitLab 프로젝트의 CI/CD 변수로 설정해야 합니다.
Jenkins 연동
Jenkins에서는 Jenkinsfile을 사용하여 파이프라인을 정의합니다. Dagger를 실행할 Jenkins 에이전트에는 Docker가 설치되어 있어야 합니다.
Jenkinsfile (Declarative Pipeline) 예시:
pipeline {
    agent {
        // Docker가 설치된 에이전트를 지정
        label 'docker-agent'
    }

    environment {
        // Dagger Cloud 토큰을 Jenkins Credentials에서 로드
        DAGGER_CLOUD_TOKEN = credentials('dagger-cloud-token-id')
    }

    stages {
        stage('Install Dagger') {
            steps {
                sh 'curl -L https://dl.dagger.io/dagger/install.sh | sh'
                sh 'export PATH="$HOME/.local/bin:$PATH"'
            }
        }
        stage('Run Dagger Pipeline') {
            steps {
                script {
                    // Git 체크아웃이 필요하다면 여기에 추가
                    // sh 'git checkout...'
                    
                    // Dagger 함수 실행
                    sh '$HOME/.local/bin/dagger call all'
                }
            }
        }
    }
}

설명:
 * agent: Docker를 사용할 수 있는 Jenkins 에이전트를 선택합니다.
 * environment: Jenkins Credentials 플러그인을 사용하여 DAGGER_CLOUD_TOKEN을 안전하게 로드합니다.
 * stages: 파이프라인을 여러 단계로 나눕니다.
   * Install Dagger 스테이지: curl을 사용하여 Dagger CLI를 설치하고 PATH를 설정합니다.
   * Run Dagger Pipeline 스테이지: sh 스텝을 사용하여 dagger call 명령어를 실행합니다.